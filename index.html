<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Black Hole Prototype</title>
    <link rel="shortcut icon" href="img/favicon.png" type="image/x-icon">
    <script src="styles.css"></script>

    <!-- Load PIXI -->
    <script src="https://pixijs.download/release/pixi.js"></script>

    <!-- Load our filter -->
    <script src="bulge-pinch-filter.js"></script>

    <!-- Load JS Folder Files for Animation and UI Elements -->
    <script src="js/bezier.js"></script>
    <script src="js/animate.js"></script>
    <script src="js/ui_elements.js"></script>

</head>

<body style="background-color: darkgray;">

    <script>


        //Audio Event Listener
        // let audio = document.createElement("audio");
        // audio.autoplay = true;
        // audio.src = "ambience.mp3";

        // document.addEventListener("mousemove", () => {
        //     audio.play();
        // });

        //The Animate Background


        //The App
        var app = new PIXI.Application({
            width: 640,
            height: 480,
            backgroundColor: 0x000000
        });
        var stage = app.stage;
        var view = app.view;

        //Add view to the document
        document.body.appendChild(app.view);

        //Filter Logic

        //Step 1: Create container w/bg
        const container = new PIXI.Container();

        //Cluster
        const cluster = PIXI.Sprite.from("img/cluster.gif");
        cluster.scale.set(3);
        cluster.x = 440;
        cluster.y = 400;
        cluster.alpha = .7;
        cluster.pivot.x = 100;
        cluster.pivot.y = 140;
        container.addChild(cluster);

        //Meteor
        const rockContainer = new PIXI.Container();
        container.addChild(rockContainer);
        const texture = PIXI.Texture.from('img/meteor.png');
        const meteor = new PIXI.Sprite(texture);
        rockContainer.addChild(meteor);
        meteor.scale.set(.15);
        meteor.tint = 0x808080;
        rockContainer.x = app.screen.width / 2;
        rockContainer.y = app.screen.height / 2;
        rockContainer.pivot.x = 320;
        rockContainer.pivot.y = 240;

        //Rotate Meteor
        app.ticker.add((delta) => {
            rockContainer.rotation -= .005 * delta;
        })

        //
        //
        //
        //START HERE FOR ANIMATED STAR BACKGROUND
        //Animate background
        const textureStar = PIXI.Texture.from('img/circle.png');
        const numStars = 1000;

        //Animate Stars
        for (let i = 0; i < numStars; i++) {
            //const star = new PIXI.Sprite(texture);
            let s = createStar();
            let k = createStar();
            let j = createStar();
            requestAnimationFrame(animate);
            function animate() {
                requestAnimationFrame(animate);
                let time = Date.now() / 1000;
                let timeTwo = Date.now() / 500;
                let timeThree = Date.now() / 300;
                let freq = i / numStars;
                let ampl = i / numStars;
                s.alpha = freq * Math.sin(time + ampl);
                k.alpha = freq * Math.cos(timeTwo + ampl);
                j.alpha = freq * Math.sin(timeThree + ampl);
            }
            container.addChild(s);
            container.addChild(k);
            container.addChild(j);
        }

        //Create stars
        function createStar() {
            let star = new PIXI.Sprite(textureStar);
            const scale = Math.random() * 2;
            star.position.x = Math.random() * 5000;
            star.position.y = Math.random() * 1000;
            star.alpha = .7;
            star.scale.x = scale / 300;
            star.scale.y = scale / 300;
            return star;
        }

        //END ANIMATED STAR BACKGROUND
        //
        //

        //Add container to stage
        app.stage.addChild(container);

        //Step 2: Load filter
        let bulge = new BulgePinchFilter({
            center: [0.5, 0.5],
            radius: 100,
            strength: 2,
        });

        //Step 3: Add filter to container
        container.filters = [bulge];

        //Slider Logic
        function makeSlider() {
            let slideContain = new PIXI.Container();
            slideContain.interactive = true;
            slideContain.value = 0;

            let track = new PIXI.Graphics();
            track.beginFill(0xCCCCCC);
            track.drawRoundedRect(200, -10, 300, 20);
            track.alpha = .7;

            slideContain.addChild(track);

            let slide = new PIXI.Graphics();
            slide.interactive = true;
            slide.beginFill(0xEEEEEE);
            slide.drawRoundedRect(175, -25, 50, 50);
            slide.alpha - .95;

            slideContain.addChild(slide);

            slide.dragging = false;
            slide.on("pointerdown", e => {
                slide.dragging = true;
            });

            slide.on("pointermove", e => {
                if (slide.dragging) {
                    let newX = e.data.global.x - slideContain.getGlobalPosition().x - 200;
                    let newY = e.data.global.y - slideContain.getGlobalPosition().y;

                    if (newX > track.width) newX = track.width;
                    if (newX < 0) newX = 0;

                    slideContain.value = newX / track.width;
                    slide.x = newX;
                    bulge.uniforms.strength = (newX);
                }
            });
            slide.on("pointerup", e => {
                slide.dragging = false;
            });
            slide.on("pointerupoutside", e => {
                slide.dragging = false;
            });
            return slideContain;
        };

        let slideContain = makeSlider();

        //
        //
        //
        //BEGIN SCENE LOGIC
        //Scene Logic

        //Title Screen
        let title = new PIXI.Container();

        //Create Shuttle Window Sprite
        let shuttleWindow = PIXI.Sprite.from('img/Rocket-Window.png');
        shuttleWindow.scale.set(.5);
        title.addChild(shuttleWindow);

        //Create First Button to begin presentation
        let beginButton = UI.Button(270,430,"ESCAPE POD");
        beginButton.scale.set(.5);
        title.addChild(beginButton);
        
        //Add title screen to stage
        app.stage.addChild(title);

        //Scene 1
        
        //Create scene as a container
        let scene1 = new PIXI.Container();

        //Create scene text
        let textIntro = new PIXI.Text("interact with me", {fill:0xFFFFFF});
        textIntro.x = 240;
        textIntro.y = 250;
        scene1.addChild(textIntro);

        //Create sprite for scene
        let astronaut = PIXI.Sprite.from('img/astronaut.png');
        astronaut.scale.set(.5);
        scene1.addChild(astronaut);

        //Create In Button to enter black hole
        let inButton = UI.Button(440,380,"In");
        scene1.addChild(inButton);

        //Create Out Button to exit black hole
        let outButton = UI.Button(0,380,"Out");
        scene1.addChild(outButton);

        //Create Next Button
        let nextButton = UI.Button(220,380,"Information");
        scene1.addChild(nextButton);

        //Add slider to scene1
        scene1.addChild(slideContain)

        //Scene 2

        //Create scene as a container
        let scene2 = new PIXI.Container();

        //Create scene text
        let scene2Text = new PIXI.Text('scene two', {fill:0xFFFFFF});
        scene2.addChild(scene2Text);

        //Create back button
        let backButton = UI.Button(0, 380, 'back');
        scene2.addChild(backButton);

        //Create next button
        let nextButtonTwo = UI.Button(440,380,'next');
        scene2.addChild(nextButtonTwo);

        //Scene 3

        //Create scene as a container
        let scene3 = new PIXI.Container();

        //Create scene text
        let scene3Text = new PIXI.Text('scene three', {fill:0xFFFFFF});
        scene3.addChild(scene3Text);

        //Create back button
        let backButtonTwo = UI.Button(0,380,'back');
        scene3.addChild(backButtonTwo);

        //Creat next button
        let nextButtonThree = UI.Button(440,380,'next');
        scene3.addChild(nextButtonThree);

        //Scene4

        //Create scene as a container
        let scene4 = new PIXI.Container();

        //Create scene text
        let scene4Text = new PIXI.Text('scene four', {fill:0xFFFFFF});
        scene4.addChild(scene4Text);

        //Create back button
        let backButtonThree = UI.Button(0,380,'back');
        scene4.addChild(backButtonThree);

        //Create next button
        let nextButtonFour = UI.Button(440,380,'next');
        scene4.addChild(nextButtonFour);

        //Scene 5

        //Create scene as a container
        let scene5 = new PIXI.Container();

        //Create scene text
        let scene5Text = new PIXI.Text('scene five', {fill:0xFFFFFF});
        scene5.addChild(scene5Text);

        //Create back button
        let backButtonFour = UI.Button(0,380,'back');
        scene5.addChild(backButtonFour);

        // Director object to manage scenes
        var Director = {

            // Object to hold list of scenes
            scene: {},

            // Add a scene to the list
            addScene: (name, scene) => {

                // If it exists throw text
                if (Director.scene[name])
                    throw "That scene already exists!"

                // Otherwise add it
                Director.scene[name] = scene;

                // If it's the first scene, make it the active one
                if (Director.currentScene == null)
                    Director.currentScene = name;

            },

            // Keep track of the current scene
            currentScene: null,

            // Change scene function
            showScene: async (nextSceneName, params) => {

                if (params == undefined) params = {};

                let currentScene = Director.scene[Director.currentScene];
                let nextScene = Director.scene[nextSceneName];

                if (params.transition == undefined)
                    params.transition = Director.cut;

                await params.transition(currentScene, nextScene, params);

                Director.currentScene = nextSceneName;

            },

            //
            // Transitions for changing scenes
            //

            // Cut (no transition)
            cut: async (currentScene, nextScene, params) => {
                app.stage.removeChild(currentScene);
                app.stage.addChild(nextScene);
            },

            //Fade between
            fade: async (currentScene, nextScene, params) => {

                // Check duration
                if (params == undefined) params = {};
                if (params.duration == undefined) params.duration = 500;

                // Fade out current scene
                await Animate.to(currentScene, { alpha: 0, duration: params.duration / 2 });
                // Remove it from stage
                app.stage.removeChild(currentScene);
                // Set next scene to zero alpha
                nextScene.alpha = 0;
                // Add it to the stage
                app.stage.addChild(nextScene);
                // Fade it in
                await Animate.to(nextScene, { alpha: 1, duration: params.duration / 2 });
                // Reset the off-stage scene's alpha back
                currentScene.alpha = 1;
            },

            // Pull focus between
            blink: async (currentScene, nextScene, params) => {

                // Check duration
                if (params == undefined) params = {};
                if (params.duration == undefined) params.duration = 500;

                // Unfocus current scene
                await Animate.to(currentScene, { alpha: 0, duration: params.duration / 2 });
                // Remove it from stage
                app.stage.removeChild(currentScene);
                // Apply Blur Filter to unfocus
                app.stage.filters = [new PIXI.filters.BlurFilter()];
                // Set next scene to zero alpha
                nextScene.alpha = 0;
                // Wait
                await pause(120)
                // Add it to the stage
                app.stage.addChild(nextScene);
                // Wait
                await pause(60)
                // Remove Blur Filter to refocus
                app.stage.filters = false;
                // Focus in to new scene
                await Animate.to(nextScene, { alpha: 1, duration: params.duration / 2 });
                // Reset the off-stage scene's alpha back
                currentScene.alpha = 1;
            },

            // Slide in a particular direction
            swipe: async (currentScene, nextScene, params) => {

                // Set up destinations
                let currentSceneEndX, currentSceneEndY;
                let nextSceneStartX, nextSceneStartY;

                // Check duration
                if (params == undefined) params = {};
                if (params.duration == undefined) params.duration = 500;

                // Set default direction
                if (params.direction == undefined) params.direction = "left";

                // Figure out initial and end positions
                if (params.direction == "left") {
                    currentSceneEndX = -app.view.width;
                    currentSceneEndY = 0;
                    nextSceneStartX = app.view.width;
                    nextSceneStartY = 0;
                }
                else if (params.direction == "right") {
                    currentSceneEndX = app.view.width;
                    currentSceneEndY = 0;
                    nextSceneStartX = -app.view.width;
                    nextSceneStartY = 0;
                }
                else if (params.direction == "up") {
                    currentSceneEndX = 0;
                    currentSceneEndY = -app.view.height;
                    nextSceneStartX = 0;
                    nextSceneStartY = app.view.height;
                }
                else if (params.direction == "down") {
                    currentSceneEndX = 0;
                    currentSceneEndY = app.view.height;
                    nextSceneStartX = 0;
                    nextSceneStartY = -app.view.height;
                }

                // Set up next scene, position, and adding to stage
                nextScene.x = nextSceneStartX;
                nextScene.y = nextSceneStartY;
                app.stage.addChild(nextScene);

                // Slide out current scene as it moves off
                Animate.to(currentScene, {
                    x: currentSceneEndX, y: currentSceneEndY,
                    duration: params.duration,
                    easing: Animate.easeInOut
                });
                // WHILE bringing in the next scene
                await Animate.to(nextScene, {
                    x: 0, y: 0,
                    duration: params.duration,
                    easing: Animate.easeInOut
                });
                // We only "await" on the last Animate, so that they both move at the same time

                // Remove the old scene from stage
                app.stage.removeChild(currentScene);

                //And just to be nice, move the old scene back to neutral
                currentScene.x = 0;
                currentScene.y = 0;

            },

        };

        //Use Director setup to manage scenes alongside button clicks
        //Change onclick to pointerdown for touch displays
        Director.addScene("title", title);
        Director.addScene("first", scene1);
        Director.addScene("second", scene2);
        Director.addScene("third", scene3);
        Director.addScene("fourth", scene4);
        Director.addScene("fifth", scene5);

        //Brings user to first scene
        beginButton.onclick = () => {
            Director.showScene("first", { transition: Director.swipe });
        }
        
        //Brings user to second scene
        nextButton.onclick = () => {
            Director.showScene("second", { transition: Director.fade });
        }

        //Returns user to first scene
        backButton.onclick = () => {
            Director.showScene("first", { transition: Director.fade });
        }

        //Brings user to third scene
        nextButtonTwo.onclick = () => {
            Director.showScene("third", { transition: Director.fade });
        }

        //Returns user to second scene
        backButtonTwo.onclick = () => {
            Director.showScene("second", { transition: Director.fade });
        }

        //Brings user to fourth scene
        nextButtonThree.onclick = () => {
            Director.showScene("fourth", { transition: Director.fade });
        }

        //Returns user to third scene
        backButtonThree.onclick = () => {
            Director.showScene("third", { transition: Director.fade });
        }

        //Bring user to fifth scene
        nextButtonFour.onclick = () => {
            Director.showScene("fifth", { transition: Director.fade });
        }

        //Return user to fourth scene
        backButtonFour.onclick = () => {
            Director.showScene("fourth", { transition: Director.fade });
        }


        //Animations

        //Astronaut idle floating animation
        async function float() {
            await Animate.to(astronaut, {
                x: 0, y: 50,
                duration: 5000,
                easing: Animate.easeInOut
            });
            await Animate.to(astronaut, {
                x: 0, y: 120,
                duration: 5000,
                easing: Animate.easeInOut
            });
            float();
        }
        float();

    </script>
    <p style="font-family: 'Courier New', Courier, monospace;">Authors: Tim, Fender, Spencer</p>

</body>

</html>