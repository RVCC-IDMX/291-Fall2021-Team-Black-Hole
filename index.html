<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Black Hole Prototype</title>
    <link rel="shortcut icon" href="img/favicon.png" type="image/x-icon">
    <script src="styles.css"></script>

    <!-- Load PIXI -->
    <script src="https://pixijs.download/release/pixi.js"></script>

    <!-- Load our filter -->
    <script src="bulge-pinch-filter.js"></script>

    <!-- Load JS Folder Files for Animation and UI Elements -->
    <script src="js/bezier.js"></script>
    <script src="js/animate.js"></script>
    <script src="js/ui_elements.js"></script>

</head>

<body style="background-color: darkgray;">

    <script>


        //Audio Event Listener
        // let audio = document.createElement("audio");
        // audio.autoplay = true;
        // audio.src = "ambience.mp3";

        // document.addEventListener("mousemove", () => {
        //     audio.play();
        // });

        //The Animate Background


        //The App
        var app = new PIXI.Application({
            width: 640,
            height: 480,
            backgroundColor: 0x000000
        });
        var stage = app.stage;
        var view = app.view;

        //Add view to the document
        document.body.appendChild(app.view);

        //Filter Logic

        //Step 1: Create container w/bg
        const container = new PIXI.Container();

        //Cluster
        const cluster = PIXI.Sprite.from("img/cluster.gif");
        cluster.scale.set(3);
        cluster.x = 440;
        cluster.y = 400;
        cluster.alpha = .7;
        cluster.pivot.x = 100;
        cluster.pivot.y = 140;
        container.addChild(cluster);

        //Meteor
        const rockContainer = new PIXI.Container();
        container.addChild(rockContainer);
        const texture = PIXI.Texture.from('img/meteor.png');
        const meteor = new PIXI.Sprite(texture);
        rockContainer.addChild(meteor);
        meteor.scale.set(.15);
        meteor.tint = 0x808080;
        rockContainer.x = app.screen.width / 2;
        rockContainer.y = app.screen.height / 2;
        rockContainer.pivot.x = 320;
        rockContainer.pivot.y = 240;

        //Rotate Meteor
        app.ticker.add((delta) => {
            rockContainer.rotation -= .005 * delta;
        })

        //
        //
        //
        //START HERE FOR ANIMATED STAR BACKGROUND
        //Animate background
        const textureStar = PIXI.Texture.from('img/circle.png');
        const numStars = 1000;

        //Animate Stars
        for (let i = 0; i < numStars; i++) {
            //const star = new PIXI.Sprite(texture);
            let s = createStar();
            let k = createStar();
            let j = createStar();
            requestAnimationFrame(animate);
            function animate() {
                requestAnimationFrame(animate);
                let time = Date.now() / 1000;
                let timeTwo = Date.now() / 500;
                let timeThree = Date.now() / 300;
                let freq = i / numStars;
                let ampl = i / numStars;
                s.alpha = freq * Math.sin(time + ampl);
                k.alpha = freq * Math.cos(timeTwo + ampl);
                j.alpha = freq * Math.sin(timeThree + ampl);
            }
            container.addChild(s);
            container.addChild(k);
            container.addChild(j);
        }

        //Create stars
        function createStar() {
            let star = new PIXI.Sprite(textureStar);
            const scale = Math.random() * 2;
            star.position.x = Math.random() * 5000;
            star.position.y = Math.random() * 1000;
            star.alpha = .7;
            star.scale.x = scale / 300;
            star.scale.y = scale / 300;
            return star;
        }

        //END ANIMATED STAR BACKGROUND
        //
        //

        //Add container to stage
        app.stage.addChild(container);

        //Step 2: Load filter
        let bulge = new BulgePinchFilter({
            center: [0.5, 0.5],
            radius: 100,
            strength: 2,
        });

        //Step 3: Add filter to container
        container.filters = [bulge];

        //Slider Logic
        function makeSlider() {
            let slideContain = new PIXI.Container();
            slideContain.interactive = true;
            slideContain.value = 0;

            let track = new PIXI.Graphics();
            track.beginFill(0xCCCCCC);
            track.drawRoundedRect(200, -10, 300, 20);
            track.alpha = .7;

            slideContain.addChild(track);

            let slide = new PIXI.Graphics();
            slide.interactive = true;
            slide.beginFill(0xEEEEEE);
            slide.drawRoundedRect(175, -25, 50, 50);
            slide.alpha - .95;

            slideContain.addChild(slide);

            slide.dragging = false;
            slide.on("pointerdown", e => {
                slide.dragging = true;
            });

            slide.on("pointermove", e => {
                if (slide.dragging) {
                    let newX = e.data.global.x - slideContain.getGlobalPosition().x - 200;
                    let newY = e.data.global.y - slideContain.getGlobalPosition().y;

                    if (newX > track.width) newX = track.width;
                    if (newX < 0) newX = 0;

                    slideContain.value = newX / track.width;
                    slide.x = newX;
                    bulge.uniforms.strength = (newX);
                }
            });
            slide.on("pointerup", e => {
                slide.dragging = false;
            });
            slide.on("pointerupoutside", e => {
                slide.dragging = false;
            });
            return slideContain;
        };

        let slideContain = makeSlider();

        //
        //
        //
        //BEGIN SCENE LOGIC
        //Scene Logic

        //Title Screen
        let title = new PIXI.Container();

        //Create Shuttle Window Sprite
        let shuttleWindow = PIXI.Sprite.from('img/Rocket-Window.png');
        shuttleWindow.scale.set(.5);
        title.addChild(shuttleWindow);

        //Create First Button to begin presentation
        let beginButton = UI.Button(270,430,"ESCAPE POD");
        beginButton.scale.set(.5);
        title.addChild(beginButton);
        
        //Add title screen to stage
        app.stage.addChild(title);

        //Scene 1
        
        //Create scene as a container
        let scene1 = new PIXI.Container();

        //Create scene text
        let textIntro = new PIXI.Text("INTERACT WITH ME", {fill:0xFFFFFF});
        textIntro.x = 200;
        textIntro.y = 50;
        scene1.addChild(textIntro);

        //Create sprite for scene
        let astronaut = PIXI.Sprite.from('img/astronaut.png');
        astronaut.scale.set(.5);
        scene1.addChild(astronaut);

        //Create In Button to enter black hole
        let inButton = UI.Button(440,380,"In");
        scene1.addChild(inButton);

        //Create Out Button to exit black hole
        let outButton = UI.Button(0,380,"Out");
        scene1.addChild(outButton);

        //Create Next Button
        let nextButton = UI.Button(220,380,"Information");
        scene1.addChild(nextButton);

        //Add slider to scene1
        scene1.addChild(slideContain)

        //Scene 2

        //Create scene as a container
        let scene2 = new PIXI.Container();

        //Create scene text
        let scene2Text = new PIXI.Text('What is a Black Hole?', {fill:0xFFFFFF});
        scene2.addChild(scene2Text);

        let scene2Content = new PIXI.Text('A black hole is recognized as an "astronomical object" with a gravitational pull so strong nothing can escape it, not even light ', {fill:0xFFFFFF, fontSize:20, align:'center', wordWrap:true, wordWrapWidth:500});
        scene2Content.x = 75;
        scene2Content.y = 50;
        scene2.addChild(scene2Content);
        
        let scene2ContentTwo = new PIXI.Text('The most common way a black hole forms is stellar death, a star will explode into a supernova at the end of its life, the release of force allowing the intense gravity to collapse. Black holes can grow and evaporate too!', {fill:0xFFFFFF, fontSize: 20, align:'center', wordWrap:true, wordWrapWidth:500,});
        scene2ContentTwo.x=75;
        scene2ContentTwo.y = 180;
        scene2.addChild(scene2ContentTwo);
        
        //Create back button
        let backButton = UI.Button(0, 380, 'back');
        scene2.addChild(backButton);

        //Create next button
        let nextButtonTwo = UI.Button(440,380,'next');
        scene2.addChild(nextButtonTwo);

        //Scene 3

        //Create scene as a container
        let scene3 = new PIXI.Container();

        //Create scene text
        let scene3Text = new PIXI.Text('Characteristics of a Black Hole/Lensing', {fill:0xFFFFFF});
        scene3.addChild(scene3Text);

        let scene3Content = new PIXI.Text('- Radius is determined by the formula R = 3M, where M is mass of the black hole in units of solar mass. ', {fill:0xFFFFFF, fontSize:20, align:'left', wordWrap:true, wordWrapWidth:500});
        scene3Content.x = 75;
        scene3Content.y = 50;
        scene3.addChild(scene3Content);

        let scene3ContentTwo = new PIXI.Text('- Red shift: Gravity is strong enough to shift colors to the red part of the spectrum. ', {fill:0xFFFFFF, fontSize:20, align:'left', wordWrap:true, wordWrapWidth:500});
        scene3ContentTwo.x = 75;
        scene3ContentTwo.y = 125;
        scene3.addChild(scene3ContentTwo);

        let scene3ContentThree = new PIXI.Text('- Lensing: The gravity that the light being bent over the hole multiple times. ', {fill:0xFFFFFF, fontSize:20, align:'left', wordWrap:true, wordWrapWidth:500});
        scene3ContentThree.x = 75;
        scene3ContentThree.y = 200;
        scene3.addChild(scene3ContentThree);

        //Create back button
        let backButtonTwo = UI.Button(0,380,'back');
        scene3.addChild(backButtonTwo);

        //Creat next button
        let nextButtonThree = UI.Button(440,380,'next');
        scene3.addChild(nextButtonThree);

        //Scene4

        //Create scene as a container
        let scene4 = new PIXI.Container();

        //Create scene text
        let scene4Text = new PIXI.Text('Types of Black Holes', {fill:0xFFFFFF});
        scene4.addChild(scene4Text);

        let scene4Content = new PIXI.Text('- Supermassive Black Holes: mass millions or billions the time of the Sun. ', {fill:0xFFFFFF, fontSize:20, align:'left', wordWrap:true, wordWrapWidth:500});
        scene4Content.x = 75;
        scene4Content.y = 50;
        scene4.addChild(scene4Content);

        let scene4ContentTwo = new PIXI.Text('- Stellar: mass 5 to 10 times the Sun, called collapsars, observed as radial energy bursts or hypernova. ', {fill:0xFFFFFF, fontSize:20, align:'left', wordWrap:true, wordWrapWidth:500});
        scene4ContentTwo.x = 75;
        scene4ContentTwo.y = 125;
        scene4.addChild(scene4ContentTwo);

        let scene4ContentThree = new PIXI.Text('- Intermediate: mass 100 to 500 times of the Sun. ', {fill:0xFFFFFF, fontSize:20, align:'left', wordWrap:true, wordWrapWidth:500});
        scene4ContentThree.x = 75;
        scene4ContentThree.y = 200;
        scene4.addChild(scene4ContentThree);

        let scene4ContentFour = new PIXI.Text('- Miniature: called quantum mechanical black holes, theoretical and smaller than stellar holes.  ', {fill:0xFFFFFF, fontSize:20, align:'left', wordWrap:true, wordWrapWidth:500});
        scene4ContentFour.x = 75;
        scene4ContentFour.y = 250;
        scene4.addChild(scene4ContentFour);

        //Create back button
        let backButtonThree = UI.Button(0,380,'back');
        scene4.addChild(backButtonThree);

        //Create next button
        let nextButtonFour = UI.Button(440,380,'next');
        scene4.addChild(nextButtonFour);

        //Scene 5

        //Create scene as a container
        let scene5 = new PIXI.Container();

        //Create scene text
        let scene5Text = new PIXI.Text('Anatomy and Physics of a Black Hole', {fill:0xFFFFFF});
        scene5.addChild(scene5Text);

        let scene5Content = new PIXI.Text('- Accretion Disk: the disklike cloud of energy, gas, plasma, dust particles that surround the body of a black hole. ', {fill:0xFFFFFF, fontSize:16, align:'left', wordWrap:true, wordWrapWidth:500});
        scene5Content.x = 75;
        scene5Content.y = 50;
        scene5.addChild(scene5Content);

        let scene5ContentTwo = new PIXI.Text('- Event Horizon: the theoretical bounds of a black hole in which no light can escape. ', {fill:0xFFFFFF, fontSize:16, align:'left', wordWrap:true, wordWrapWidth:500});
        scene5ContentTwo.x = 75;
        scene5ContentTwo.y = 100;
        scene5.addChild(scene5ContentTwo);

        let scene5ContentThree = new PIXI.Text('- Singularity: the center of a black hole, the infinitely compressed point of no return. ', {fill:0xFFFFFF, fontSize:16, align:'left', wordWrap:true, wordWrapWidth:500});
        scene5ContentThree.x = 75;
        scene5ContentThree.y = 150;
        scene5.addChild(scene5ContentThree);

        let scene5ContentFour = new PIXI.Text('- Spaghettifiction: the vertical stretching and horizontal compression of objects into thin streams of particles. ', {fill:0xFFFFFF, fontSize:16, align:'left', wordWrap:true, wordWrapWidth:500});
        scene5ContentFour.x = 75;
        scene5ContentFour.y = 200;
        scene5.addChild(scene5ContentFour);

        let scene5ContentFive = new PIXI.Text('- Space/time: thought of like a fabric, the relation between space and time is warped by gravity, making time go by slower the larger the mass and warp of spacetime and faster the smaller the mass and warp of spacetime, also called time dilation; black holes are so dense, that energy cannot escape this warp. ', {fill:0xFFFFFF, fontSize:16, align:'left', wordWrap:true, wordWrapWidth:500})
        scene5ContentFive.x = 75;
        scene5ContentFive.y = 250;
        scene5.addChild(scene5ContentFive);

        //Create back button
        let backButtonFour = UI.Button(0,380,'back');
        scene5.addChild(backButtonFour);

        // Director object to manage scenes
        var Director = {

            // Object to hold list of scenes
            scene: {},

            // Add a scene to the list
            addScene: (name, scene) => {

                // If it exists throw text
                if (Director.scene[name])
                    throw "That scene already exists!"

                // Otherwise add it
                Director.scene[name] = scene;

                // If it's the first scene, make it the active one
                if (Director.currentScene == null)
                    Director.currentScene = name;

            },

            // Keep track of the current scene
            currentScene: null,

            // Change scene function
            showScene: async (nextSceneName, params) => {

                if (params == undefined) params = {};

                let currentScene = Director.scene[Director.currentScene];
                let nextScene = Director.scene[nextSceneName];

                if (params.transition == undefined)
                    params.transition = Director.cut;

                await params.transition(currentScene, nextScene, params);

                Director.currentScene = nextSceneName;

            },

            //
            // Transitions for changing scenes
            //

            // Cut (no transition)
            cut: async (currentScene, nextScene, params) => {
                app.stage.removeChild(currentScene);
                app.stage.addChild(nextScene);
            },

            //Fade between
            fade: async (currentScene, nextScene, params) => {

                // Check duration
                if (params == undefined) params = {};
                if (params.duration == undefined) params.duration = 500;

                // Fade out current scene
                await Animate.to(currentScene, { alpha: 0, duration: params.duration / 2 });
                // Remove it from stage
                app.stage.removeChild(currentScene);
                // Set next scene to zero alpha
                nextScene.alpha = 0;
                // Add it to the stage
                app.stage.addChild(nextScene);
                // Fade it in
                await Animate.to(nextScene, { alpha: 1, duration: params.duration / 2 });
                // Reset the off-stage scene's alpha back
                currentScene.alpha = 1;
            },

            // Pull focus between
            blink: async (currentScene, nextScene, params) => {

                // Check duration
                if (params == undefined) params = {};
                if (params.duration == undefined) params.duration = 500;

                // Unfocus current scene
                await Animate.to(currentScene, { alpha: 0, duration: params.duration / 2 });
                // Remove it from stage
                app.stage.removeChild(currentScene);
                // Apply Blur Filter to unfocus
                app.stage.filters = [new PIXI.filters.BlurFilter()];
                // Set next scene to zero alpha
                nextScene.alpha = 0;
                // Wait
                await pause(120)
                // Add it to the stage
                app.stage.addChild(nextScene);
                // Wait
                await pause(60)
                // Remove Blur Filter to refocus
                app.stage.filters = false;
                // Focus in to new scene
                await Animate.to(nextScene, { alpha: 1, duration: params.duration / 2 });
                // Reset the off-stage scene's alpha back
                currentScene.alpha = 1;
            },

            // Slide in a particular direction
            swipe: async (currentScene, nextScene, params) => {

                // Set up destinations
                let currentSceneEndX, currentSceneEndY;
                let nextSceneStartX, nextSceneStartY;

                // Check duration
                if (params == undefined) params = {};
                if (params.duration == undefined) params.duration = 500;

                // Set default direction
                if (params.direction == undefined) params.direction = "left";

                // Figure out initial and end positions
                if (params.direction == "left") {
                    currentSceneEndX = -app.view.width;
                    currentSceneEndY = 0;
                    nextSceneStartX = app.view.width;
                    nextSceneStartY = 0;
                }
                else if (params.direction == "right") {
                    currentSceneEndX = app.view.width;
                    currentSceneEndY = 0;
                    nextSceneStartX = -app.view.width;
                    nextSceneStartY = 0;
                }
                else if (params.direction == "up") {
                    currentSceneEndX = 0;
                    currentSceneEndY = -app.view.height;
                    nextSceneStartX = 0;
                    nextSceneStartY = app.view.height;
                }
                else if (params.direction == "down") {
                    currentSceneEndX = 0;
                    currentSceneEndY = app.view.height;
                    nextSceneStartX = 0;
                    nextSceneStartY = -app.view.height;
                }

                // Set up next scene, position, and adding to stage
                nextScene.x = nextSceneStartX;
                nextScene.y = nextSceneStartY;
                app.stage.addChild(nextScene);

                // Slide out current scene as it moves off
                Animate.to(currentScene, {
                    x: currentSceneEndX, y: currentSceneEndY,
                    duration: params.duration,
                    easing: Animate.easeInOut
                });
                // WHILE bringing in the next scene
                await Animate.to(nextScene, {
                    x: 0, y: 0,
                    duration: params.duration,
                    easing: Animate.easeInOut
                });
                // We only "await" on the last Animate, so that they both move at the same time

                // Remove the old scene from stage
                app.stage.removeChild(currentScene);

                //And just to be nice, move the old scene back to neutral
                currentScene.x = 0;
                currentScene.y = 0;

            },

        };

        //Use Director setup to manage scenes alongside button clicks
        //Change onclick to pointerdown for touch displays
        Director.addScene("title", title);
        Director.addScene("first", scene1);
        Director.addScene("second", scene2);
        Director.addScene("third", scene3);
        Director.addScene("fourth", scene4);
        Director.addScene("fifth", scene5);

        //Brings user to first scene
        beginButton.onclick = () => {
            Director.showScene("first", { transition: Director.swipe });
        }
        
        //Brings user to second scene
        nextButton.onclick = () => {
            Director.showScene("second", { transition: Director.fade });
        }

        //Returns user to first scene
        backButton.onclick = () => {
            Director.showScene("first", { transition: Director.fade });
        }

        //Brings user to third scene
        nextButtonTwo.onclick = () => {
            Director.showScene("third", { transition: Director.fade });
        }

        //Returns user to second scene
        backButtonTwo.onclick = () => {
            Director.showScene("second", { transition: Director.fade });
        }

        //Brings user to fourth scene
        nextButtonThree.onclick = () => {
            Director.showScene("fourth", { transition: Director.fade });
        }

        //Returns user to third scene
        backButtonThree.onclick = () => {
            Director.showScene("third", { transition: Director.fade });
        }

        //Bring user to fifth scene
        nextButtonFour.onclick = () => {
            Director.showScene("fifth", { transition: Director.fade });
        }

        //Return user to fourth scene
        backButtonFour.onclick = () => {
            Director.showScene("fourth", { transition: Director.fade });
        }


        //Animations

        //Astronaut idle floating animation
        async function float() {
            await Animate.to(astronaut, {
                x: 0, y: 50,
                duration: 5000,
                easing: Animate.easeInOut
            });
            await Animate.to(astronaut, {
                x: 0, y: 120,
                duration: 5000,
                easing: Animate.easeInOut
            });
            float();
        }
        float();

    </script>
    <p style="font-family: 'Courier New', Courier, monospace;">Authors: Tim, Fender, Spencer</p>

</body>

</html>